dplyr::filter(DEG!="NS") %>%
# Arrange by ascendent order of padjusted
dplyr::arrange(desc(abs(log2FoldChange))) %>%
# Create a dataframe with the labels of the DEGs with highest abs(log2FC).
dplyr::slice(1:degsLabelNum) %>% as.data.frame()
# Put labels in the plot
p <- p + ggrepel::geom_text_repel(data = degs, size = degsLabelSize, color = "Black",
mapping = aes(x = log2FoldChange, y = -log10(padj), label = Geneid))
}
} else if(is.character(degsLabel)){
#("'degsLabel' is character, so the written genes will be printed on the plot")
# Load ggrepel
require(ggrepel)
# Organaize and retrieve lowest p-value genes
degs <- df %>%
# Filter for only the genes that are wanted
dplyr::filter(Geneid %in% degsLabel)
# Put labels in the plot
p <- p + geom_text_repel(data = degs, mapping = aes(x = log2FoldChange, y = -log10(padj), label = Geneid), size = degsLabelSize, color = "Black")
}
# Draw the graph.
return(p)
p
volcanoPlot <- function(df,
xlim          = c(-10,10),
ylim          = c(0,30),
pval          = 0.05,
log2FC        = 1,
main          = NULL,
mainSize      = 9,
sub           = NULL,
subSize       = 8,
labelSize     = 5,
labelColor    = c("darkgreen", "red"),
labelPos      = 0,
xlab          = bquote(~Log[2]~ "FC"),
ylab          = (bquote(~-Log[10]~italic(P))),
axisLabelSize = 10,
axisTextSize  = 9,
pointColor    = c("darkgreen", "gray", "red"),
legendTitle   = FALSE,
legendPos     = "bottom",
degsLabel     = FALSE,
degsLabelNum  = 5,
degsLabelSize = 3,
gridLines     = TRUE) {
# Load packages
require(ggplot2)
require(dplyr)
# Check if inputs are OK
if(!is.data.frame(df)) { stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
if(!'Geneid' %in% colnames(df)){ stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
if(!'padj' %in% colnames(df)){ stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
if(!'log2FoldChange' %in% colnames(df)){ stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
else if(length(pointColor) != 3 | !is.character(pointColor)){ stop("'pointColor' must be a character vector of length 3 with valid color names or codes.") }
# Format DEG column
df <- df %>% mutate(DEG = "NS")
df <- df %>% mutate(DEG = ifelse(padj < pval & log2FoldChange > log2FC, "Upregulated", DEG))
df <- df %>% mutate(DEG = ifelse(padj < pval & log2FoldChange < -log2FC, "Downregulated", DEG))
# Format data frame.
df <- df %>%
# Mutate the data frame to convert NA in padj to 1
dplyr::mutate(padj = ifelse(test = is.na(padj), yes = 1, no = padj)) %>%
# Mutate the data frame to convert NA in log2FoldChange to 0
dplyr::mutate(log2FoldChange = ifelse(test = is.na(log2FoldChange), yes = 0, no = log2FoldChange)) %>%
# Mutate the dataframe to convert NA in DEG to "NS".
dplyr::mutate(DEG = ifelse(test = is.na(DEG), yes = "NS", no = DEG)) %>%
# Mutate the dataframe to include the shape of the points.
# Shape of al the points
dplyr::mutate(shape = "circle") %>%
# Change the shape of the point to triangle if the -log10(padj) is greater than the ylim variable
dplyr::mutate(shape = ifelse(test = -log10(padj) > ylim[2], yes = "triangle", no = shape)) %>%
# Change the shape of the points to triangle if the log2FoldChange is greater or lower than the xlim
dplyr::mutate(shape = ifelse(test = log2FoldChange > xlim[2], yes = "triangle", no = shape)) %>%
dplyr::mutate(shape = ifelse(test = log2FoldChange < xlim[1], yes = "triangle", no = shape)) %>%
# Change the padj to the value that plots the points at the top of the graph.
dplyr::mutate(padj  = ifelse(test = -log10(padj) > ylim[2], yes = 10^-ylim[2], no = padj)) %>%
# Change the log2FoldChange of the points with log2FoldChange than the limits, so they will be plotted in the limits of the graph
dplyr::mutate(log2FoldChange = ifelse(test = log2FoldChange > xlim[2], yes = xlim[2], no = log2FoldChange)) %>%
dplyr::mutate(log2FoldChange = ifelse(test = log2FoldChange < xlim[1], yes = xlim[1], no = log2FoldChange))
# Count number of differentially expressed genes and join to the DE data frame
deg_number <- data.frame(DEG    = c("Upregulated", "Downregulated",  NA),
number = c(sum(df$DEG == "Upregulated"),sum(df$DEG == "Downregulated"), NA),
xpos   = c(xlim[2], xlim[1], 0))
df <- df %>% dplyr::left_join(deg_number, by = "DEG") %>%
dplyr::group_by(number) %>% dplyr::mutate(row = row_number()) %>% dplyr::ungroup() %>%
dplyr::mutate(number = ifelse(row != 1, NA, number))
updegs   <- deg_number %>% dplyr::filter(DEG == "Upregulated")
downdegs <- deg_number %>% dplyr::filter(DEG == "Downregulated")
# Initialize ggplot with points
p <- ggplot(data = df, aes(x=log2FoldChange, y=-log10(padj), color=DEG, shape=shape)) +
geom_point(alpha=0.7, size=1.7) +
# Add number of DEGs.
annotate(geom = "text", label = updegs$number[1], x = updegs$xpos[1]*0.9, y = ylim[1], color = labelColor[2], size = labelSize) +
annotate(geom = "text", label = downdegs$number[1], x = downdegs$xpos[1]*0.9, y = ylim[1], color = labelColor[1], size = labelSize)
# Basic formatting
p <-
p +
# Stablish a predefined theme
theme_classic() +
# Write and format the graph title, can be nothing.
ggtitle(label = main, subtitle = sub) +
theme(plot.title = element_text(face="bold", hjust = .5, size = mainSize),
plot.subtitle = element_text(face = "italic", hjust = .5, size = subSize)) +
# Stablish the x and y axes ranges.
coord_cartesian(xlim = xlim, ylim = ylim) +
# Put an horizontal line in the -log10(pval) value and two vertival lines in the -logFC and logFC values.
geom_hline(yintercept = -log10(pval), linetype = 2) +
geom_vline(xintercept = c(-log2FC, log2FC), linetype = 2) +
# Format the axis names and sizes
xlab(xlab) + ylab(ylab) + theme(axis.title = element_text(size = axisLabelSize, face = "bold")) +
# Format the color of the points
scale_colour_manual(values = c("Downregulated" = pointColor[1], "NS" = pointColor[2], "Upregulated" = pointColor[3]),
labels = c("Downregulated" = "Downregulated", "NS" = "NS", "Upregulated" = "Upregulated"),
breaks = c("Downregulated", "NS", "Upregulated"),
limits = c("Downregulated", "NS", "Upregulated"),
drop   = F) +
# Remove the legend for shape
guides(shape="none") +
# Format the axis values
theme(axis.text = element_text(size = axisTextSize)) +
# Decide the position of the legend (default: "bottom")
theme(legend.position = legendPos)
# Add grid.lines. Default: added
if(gridLines){
p <- p + theme(panel.grid.major = element_line(size = 0.15, colour = "gray60", linetype = "dashed"))
}
# Decide if legend title is writen or not. Default: not writen.
if(!legendTitle){
p <- p + theme(legend.title = element_blank())
}
# Write names of the most DE genes in terms of lowest adjusted p-value
if(is.logical(degsLabel)){
#("'degsLabel' is logical. If TRUE, the most significant DEGs will be printed on thee plot.")
if(degsLabel){
# Load ggrepel
require(ggrepel)
# Organaize and retrieve lowest p-value genes
degs <- df %>%
# Filter non significant genes
dplyr::filter(DEG!="NS") %>%
# Arrange by ascendent order of padjusted
dplyr::arrange(desc(abs(log2FoldChange))) %>%
# Create a dataframe with the labels of the DEGs with highest abs(log2FC).
dplyr::slice(1:degsLabelNum) %>% as.data.frame()
# Put labels in the plot
p <- p + ggrepel::geom_text_repel(data = degs, size = degsLabelSize, color = "Black",
mapping = aes(x = log2FoldChange, y = -log10(padj), label = Geneid))
}
} else if(is.character(degsLabel)){
#("'degsLabel' is character, so the written genes will be printed on the plot")
# Load ggrepel
require(ggrepel)
# Organaize and retrieve lowest p-value genes
degs <- df %>%
# Filter for only the genes that are wanted
dplyr::filter(Geneid %in% degsLabel)
# Put labels in the plot
p <- p + geom_text_repel(data = degs, mapping = aes(x = log2FoldChange, y = -log10(padj), label = Geneid), size = degsLabelSize, color = "Black")
}
# Draw the graph.
return(p)
}
volcanoPlot <- function(df,
xlim          = c(-10,10),
ylim          = c(0,30),
pval          = 0.05,
log2FC        = 1,
main          = NULL,
mainSize      = 9,
sub           = NULL,
subSize       = 8,
labelSize     = 5,
labelColor    = c("darkgreen", "red"),
labelPos      = 0,
xlab          = bquote(~Log[2]~ "FC"),
ylab          = (bquote(~-Log[10]~italic(P))),
axisLabelSize = 10,
axisTextSize  = 9,
pointColor    = c("darkgreen", "gray", "red"),
legendTitle   = FALSE,
legendPos     = "bottom",
degsLabel     = FALSE,
degsLabelNum  = 5,
degsLabelSize = 3,
gridLines     = TRUE) {
# Load packages
require(ggplot2)
require(dplyr)
# Check if inputs are OK
if(!is.data.frame(df)) { stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
if(!'Geneid' %in% colnames(df)){ stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
if(!'padj' %in% colnames(df)){ stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
if(!'log2FoldChange' %in% colnames(df)){ stop("'df' must be a data frame with the columns 'Geneid', 'padj', 'log2FoldChange'.") }
else if(length(pointColor) != 3 | !is.character(pointColor)){ stop("'pointColor' must be a character vector of length 3 with valid color names or codes.") }
# Format DEG column
df <- df %>% mutate(DEG = "NS")
df <- df %>% mutate(DEG = ifelse(padj < pval & log2FoldChange > log2FC, "Upregulated", DEG))
df <- df %>% mutate(DEG = ifelse(padj < pval & log2FoldChange < -log2FC, "Downregulated", DEG))
# Format data frame.
df <- df %>%
# Mutate the data frame to convert NA in padj to 1
dplyr::mutate(padj = ifelse(test = is.na(padj), yes = 1, no = padj)) %>%
# Mutate the data frame to convert NA in log2FoldChange to 0
dplyr::mutate(log2FoldChange = ifelse(test = is.na(log2FoldChange), yes = 0, no = log2FoldChange)) %>%
# Mutate the dataframe to convert NA in DEG to "NS".
dplyr::mutate(DEG = ifelse(test = is.na(DEG), yes = "NS", no = DEG)) %>%
# Mutate the dataframe to include the shape of the points.
# Shape of al the points
dplyr::mutate(shape = "circle") %>%
# Change the shape of the point to triangle if the -log10(padj) is greater than the ylim variable
dplyr::mutate(shape = ifelse(test = -log10(padj) > ylim[2], yes = "triangle", no = shape)) %>%
# Change the shape of the points to triangle if the log2FoldChange is greater or lower than the xlim
dplyr::mutate(shape = ifelse(test = log2FoldChange > xlim[2], yes = "triangle", no = shape)) %>%
dplyr::mutate(shape = ifelse(test = log2FoldChange < xlim[1], yes = "triangle", no = shape)) %>%
# Change the padj to the value that plots the points at the top of the graph.
dplyr::mutate(padj  = ifelse(test = -log10(padj) > ylim[2], yes = 10^-ylim[2], no = padj)) %>%
# Change the log2FoldChange of the points with log2FoldChange than the limits, so they will be plotted in the limits of the graph
dplyr::mutate(log2FoldChange = ifelse(test = log2FoldChange > xlim[2], yes = xlim[2], no = log2FoldChange)) %>%
dplyr::mutate(log2FoldChange = ifelse(test = log2FoldChange < xlim[1], yes = xlim[1], no = log2FoldChange))
# Count number of differentially expressed genes and join to the DE data frame
deg_number <- data.frame(DEG    = c("Upregulated", "Downregulated",  NA),
number = c(sum(df$DEG == "Upregulated"),sum(df$DEG == "Downregulated"), NA),
xpos   = c(xlim[2], xlim[1], 0))
df <- df %>% dplyr::left_join(deg_number, by = "DEG") %>%
dplyr::group_by(number) %>% dplyr::mutate(row = row_number()) %>% dplyr::ungroup() %>%
dplyr::mutate(number = ifelse(row != 1, NA, number))
updegs   <- deg_number %>% dplyr::filter(DEG == "Upregulated")
downdegs <- deg_number %>% dplyr::filter(DEG == "Downregulated")
# Initialize ggplot with points
p <- ggplot(data = df, aes(x=log2FoldChange, y=-log10(padj), color=DEG, shape=shape)) +
geom_point(alpha=0.7, size=1.7) +
# Add number of DEGs.
annotate(geom = "text", label = updegs$number[1], x = updegs$xpos[1]*0.9, y = ylim[1], color = labelColor[2], size = labelSize) +
annotate(geom = "text", label = downdegs$number[1], x = downdegs$xpos[1]*0.9, y = ylim[1], color = labelColor[1], size = labelSize)
# Basic formatting
p <-
p +
# Stablish a predefined theme
theme_classic() +
# Write and format the graph title, can be nothing.
ggtitle(label = main, subtitle = sub) +
theme(plot.title = element_text(face="bold", hjust = .5, size = mainSize),
plot.subtitle = element_text(face = "italic", hjust = .5, size = subSize)) +
# Stablish the x and y axes ranges.
coord_cartesian(xlim = xlim, ylim = ylim) +
# Put an horizontal line in the -log10(pval) value and two vertival lines in the -logFC and logFC values.
geom_hline(yintercept = -log10(pval), linetype = 2) +
geom_vline(xintercept = c(-log2FC, log2FC), linetype = 2) +
# Format the axis names and sizes
xlab(xlab) + ylab(ylab) + theme(axis.title = element_text(size = axisLabelSize, face = "bold")) +
# Format the color of the points
scale_colour_manual(values = c("Downregulated" = pointColor[1], "NS" = pointColor[2], "Upregulated" = pointColor[3]),
labels = c("Downregulated" = "Downregulated", "NS" = "NS", "Upregulated" = "Upregulated"),
breaks = c("Downregulated", "NS", "Upregulated"),
limits = c("Downregulated", "NS", "Upregulated"),
drop   = F) +
# Remove the legend for shape
guides(shape="none") +
# Format the axis values
theme(axis.text = element_text(size = axisTextSize)) +
# Decide the position of the legend (default: "bottom")
theme(legend.position = legendPos)
# Add grid.lines. Default: added
if(gridLines){
p <- p + theme(panel.grid.major = element_line(size = 0.15, colour = "gray60", linetype = "dashed"))
}
# Decide if legend title is writen or not. Default: not writen.
if(!legendTitle){
p <- p + theme(legend.title = element_blank())
}
# Write names of the most DE genes in terms of lowest adjusted p-value
if(is.logical(degsLabel)){
#("'degsLabel' is logical. If TRUE, the most significant DEGs will be printed on thee plot.")
if(degsLabel){
# Load ggrepel
require(ggrepel)
# Organaize and retrieve lowest p-value genes
degs <- df %>%
# Filter non significant genes
dplyr::filter(DEG!="NS") %>%
# Arrange by ascendent order of padjusted
dplyr::arrange(desc(abs(log2FoldChange))) %>%
# Create a dataframe with the labels of the DEGs with highest abs(log2FC).
dplyr::slice(1:degsLabelNum) %>% as.data.frame()
# Put labels in the plot
p <- p + ggrepel::geom_text_repel(data = degs, size = degsLabelSize, color = "Black",
mapping = aes(x = log2FoldChange, y = -log10(padj), label = Geneid))
}
} else if(is.character(degsLabel)){
#("'degsLabel' is character, so the written genes will be printed on the plot")
# Load ggrepel
require(ggrepel)
# Organaize and retrieve lowest p-value genes
degs <- df %>%
# Filter for only the genes that are wanted
dplyr::filter(Geneid %in% degsLabel)
# Put labels in the plot
p <- p + geom_text_repel(data = degs, mapping = aes(x = log2FoldChange, y = -log10(padj), label = Geneid), size = degsLabelSize, color = "Black")
}
# Draw the graph.
return(p)
}
volcanoPlot(df = deg_list[[1]] %>% dplyr::mutate(log2FoldChange = abs(log2FoldChange)))
pkgdown::build_home()
knitr::opts_chunk$set(echo = TRUE, fig.align = "center", fig.width = 6, fig.height = 3,
error = FALSE, message = FALSE, warning = FALSE)
devtools::load_all("..")
library(dplyr)
library(purrr)
plot <- barDEGs(deg_list = deg_list, prop_test = T, xlim = c(-430,670))
# read the dataframes into a list
deg_list <- list.files("../testdata", "diff_exp", full.names = T, recursive = T) %>%
purrr::set_names(paste("cond", 1:3, sep = "")) %>%
purrr::map(~read.delim(.x))
deg_list[[1]] <- deg_list[[1]] %>% dplyr::mutate(log2FoldChange = abs(log2FoldChange))
barDEGs(deg_list = deg_list)
# read the dataframes into a list
deg_list <- list.files("../testdata", "diff_exp", full.names = T, recursive = T) %>%
purrr::set_names(paste("cond", 1:3, sep = "")) %>%
purrr::map(~read.delim(.x))
deg_list3 <- deg_list %>% purrr::map(~dplyr::mutate(.x, log2FoldChange = abs(log2FoldChange)))
deg_list3
barDEGs(deg_list = deg_list3)
devtools::document()
pkgdown::build_article(name = "03-volcanoPlot")
pkgdown::build_home()
devtools::install_github("amitjavilaventura/plotmics")
#'
#' @export
expressionCor <- function(df,
genes              = NULL,
samples            = NULL,
samples_order      = samples,
corr_method        = "pearson",
plot_type          = "lower",
plot_diagonal      = TRUE,
plot_size          = 85,
plot_border        = TRUE,
plot_colors        = c("Gold3", "White", "Cornflowerblue"),
plot_title         = NULL,
plot_subtitle      = NULL,
plot_caption       = NULL,
cell_border        = "Black",
legend_pos         = "right",
legend_size        = c(8,plot_size),
legend_limits      = c(-1,1),
legend_breaks_by   = 0.5,
legend_title       = paste(stringr::str_to_sentence(corr_method), "correlation", sep = " "),
legend_title_size  = 10,
legend_frame_width = 0.5,
ticks              = F,
ticks_color        = NA,
coeffs_color       = "Black",
coeffs_size        = 4,
title_hjust        = .5,
title_face         = "plain",
title_size         = 12,
subtitle_face      = "italic",
subtitle_size      = 11,
caption_size       = 6,
axis_text_size     = 8,
axis_text_color    = "black",
by_groups          = F) {
# Load packages -----
require(dplyr)
require(tibble)
require(reshape2)
require(ggplot2)
require(ggh4x)
require(ggpubr)
require(scales)
# Check that inputs are OK
if(by_groups & !"group" %in% colnames(df)) { stop("If 'by_groups' is TRUE, a column named 'group' must be in the input 'df'.") }
# Format and filter data frame -----
df_filt <- df %>% na.omit()
# Filter genes and samples if those are indicated
if(!is.null(genes)) { df_filt <- df_filt %>% dplyr::filter(Geneid %in% genes) }
if(!is.null(samples)) { df_filt <- df_filt %>% dplyr::select(c("Geneid", samples)) }
# If argument genes is NULL, don't use Geneid column
if(is.null(genes)){
if("Geneid" %in% colnames(df_filt)) { df_filt <- df_filt %>% dplyr::select(-Geneid)}
else { df_filt <- df_filt }
}
# If the by_groups option is set to FALSE (default)
if(!by_groups){
# Remove group column is present
if("group" %in% colnames(df_filt)){ df_filt <- df_filt %>% dplyr::select(-group) }
# Do correlation and format the correlation matrix -----
if(!is.null(genes)) { corr <- df_filt %>% tibble::column_to_rownames("Geneid") %>% cor(method = corr_method) }
else { corr <- df_filt %>% cor(method = corr_method) }
# Set plot type as full, upper or lower, including whether or not to plot the diagonal
if(plot_type == "full"){ corr <- corr }
else if(plot_type == "upper") { corr[lower.tri(corr, diag = !plot_diagonal)] <- NA }
else if(plot_type == "lower") { corr[upper.tri(corr, diag = !plot_diagonal)] <- NA }
# Melt correlation matrix
corr.m <- reshape2::melt(corr) %>% dplyr::as_tibble()
# Add order for samples (or columns used to compute the correlation)
if(!is.null(samples_order)) { corr.m <- corr.m %>% dplyr::mutate(Var1 = factor(Var1, levels = samples_order), Var2 = factor(Var2, levels = samples_order)) }
# Draw the plot ----
# Initialize the plot and the squares
g <- ggplot(corr.m, aes(Var1, Var2, fill = value)) + geom_tile(color = cell_border, na.rm = T)
} else {
# Initialize list for correlation values
corr_list <- list()
# For each group, do:
for(i in unique(df_filt$group)){
# Filter the data frame by group and remove group variable
df_filt_group <- df_filt %>% dplyr::filter(group == i) %>% dplyr::select(-group)
# Compute correlation
if(!is.null(genes)) { corr <- df_filt_group %>% tibble::column_to_rownames("Geneid") %>% cor(method = corr_method) }
else { corr <- df_filt_group %>% cor(method = corr_method) }
# Format the correlation matrix to draw a full, upper or lower plot, including whether to plot the diagonal or not.
if(plot_type == "full"){ corr <- corr }
else if(plot_type == "upper") { corr[lower.tri(corr, diag = !plot_diagonal)] <- NA }
else if(plot_type == "lower") { corr[upper.tri(corr, diag = !plot_diagonal)] <- NA }
# Format the correlation matrix into a dataframe and add it to the correlation list
corr_list[[i]] <- corr %>% as.data.frame()  %>% tibble::rownames_to_column("sample") %>% dplyr::mutate(group = i)
}
# Bind all the elements in the correlation list into a unique data frame
corr_list <- dplyr::bind_rows(corr_list)
# Reshape the correlation dataframe
corr_list_melt <- corr_list %>% reshape2::melt() %>% dplyr::as_tibble()
if(!is.null(samples_order)) { corr_list_melt <- corr_list_melt %>% dplyr::mutate(sample = factor(sample, levels = samples_order), variable = factor(variable, levels = samples_order)) }
# Initialize the plot with facets
g <- ggplot(corr_list_melt, aes(sample, variable, fill = value)) +
geom_tile(color = cell_border, na.rm = T) +
facet_wrap(~group)
}
# Force size of the heatmap
g <- g + ggh4x::force_panelsizes(rows = unit(plot_size, "mm"), cols = unit(plot_size, "mm")) +
scale_x_discrete(expand = c(0,0)) + scale_y_discrete(expand = c(0,0))
# Theme pubr
g <- g + theme_pubr(border = plot_border, legend = legend_pos)
# Setup the legend
if(legend_pos %in% c("right")) { legend_height <- legend_size[2]; legend_width <- legend_size[1]; legend_title_angle = 270; legend_title_pos = "right" }
else if(legend_pos %in% c("left")) { legend_height <- legend_size[2]; legend_width <- legend_size[1]; legend_title_angle = 90; legend_title_pos = "left" }
else if(legend_pos %in% c("bottom")) { legend_size <- rev(legend_size); legend_height <- legend_size[2]; legend_width <- legend_size[1]; legend_title_angle = 0; legend_title_pos = "bottom" }
else if(legend_pos %in% c("top")) { legend_size <- rev(legend_size); legend_height <- legend_size[2]; legend_width <- legend_size[1]; legend_title_angle = 0; legend_title_pos = "top" }
# Format the legend
g <- g + scale_fill_gradient2(limits = legend_limits, midpoint = median(legend_limits),
breaks = seq(legend_limits[1],legend_limits[2],legend_breaks_by), na.value = NA,
oob = scales::squish, ## to put out of bound values into scale
low = plot_colors[1], high = plot_colors[3], mid = plot_colors[2],
guide = guide_colorbar(title = legend_title,
title.position = legend_title_pos,
title.theme = element_text(angle = legend_title_angle,
hjust = .5, vjust = .5,
size = legend_title_size),
frame.colour = "black", frame.linewidth = legend_frame_width,
ticks = ticks, ticks.colour = ticks_color,
barheight = unit(legend_height, "mm"),
barwidth  = unit(legend_width, "mm")))
# Draw the coefficients
if(!is.null(coeffs_color)) { g <- g + geom_text(aes(label = round(value, 2)), color = coeffs_color, size = coeffs_size, na.rm = T) }
# Add title, subtitle and caption
if(!is.null(plot_title)) { g <- g + ggtitle( label = plot_title, subtitle = plot_subtitle ) }
if(!is.null(plot_caption)) { g <- g + labs( caption  = plot_caption) }
# Format theme
g <- g + theme(plot.title    = element_text(face = title_face, size = title_size, hjust = title_hjust),
plot.subtitle = element_text(face = subtitle_face, size = subtitle_size, hjust = title_hjust),
plot.caption  = element_text(size = caption_size),
axis.title    = element_blank(),
axis.ticks    = element_blank(),
axis.text     = element_text(size = axis_text_size, colour = axis_text_color),
axis.text.x   = element_text(angle = 90, hjust = 1, vjust = .5),
panel.border  = element_rect(size = 1.1))
return(g)
}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, error = FALSE,
fig.width = 6, fig.height = 5, fig.align = "center")
library(tidyverse)
library(tidyverse)
library(ggpubr)
library(patchwork)
```{r}
expr <- read.delim("../testdata/tpm.tsv")
expr[1:5,1:5]
expressionCor(df = expr)
expr2 <- expr %>% dplyr::mutate(group = c(rep(c("group1", "group2", "group3"), nrow(expr)/3), "group1", "group2"))
head(expr2)
expressionCor(df = expr2, samples = colnames(expr2)[-1], by_groups = T)
expressionCor(df = expr, corr_method = "pearson") + labs(title = "Pearson correlation (default)") +
expressionCor(df = expr, corr_method = "spearman") + labs(title = "Spearman correlation")
expressionCor(df = expr, genes = c("WASH7P", "FAM138A", "AL627309.1")) + labs(title = "Subset of genes") +
expressionCor(df = expr, samples = c("cond3_rep2", "cond1_rep1", "cond2_rep1")) + labs(title = "Subset of samples")
```{r fig.width=12, fig.height=4}
expressionCor(df = expr, plot_type = "lower") + labs(title = "Lower plot (default)") +
expressionCor(df = expr, plot_type = "upper") + labs(title = "Upper plot") +
expressionCor(df = expr, plot_type = "full") + labs(title = "Full plot")
expressionCor(df = expr, plot_diagonal = F)
expressionCor(df = expr, coeffs_color = "Black") +
expressionCor(df = expr, coeffs_color = "Red", coeffs_size = 6)
expressionCor(expr, plot_colors = c("blue", "yellow", "red"))
expressionCor(df = expr, plot_size = 50)
expressionCor(df = expr, plot_title = "Title", plot_subtitle = "Subtitle", plot_caption = "Caption")
expressionCor(df = expr,axis_text_color = "blue", axis_text_size = 7)
expressionCor(df = expr) +
expressionCor(df = expr, cell_border = "Red") +
expressionCor(df = expr, cell_border = "NA")
expressionCor(df = expr, legend_limits = c(0.9,1), legend_breaks_by = 0.05)
expressionCor(df = expr, legend_title  = "Title of the legend")
(expressionCor(df = expr, legend_pos = "left", legend_title = "Legend at the left") +
expressionCor(df = expr, legend_pos = "right", legend_title = "Legend at the right")) /
(expressionCor(df = expr, legend_pos = "top", legend_title = "Legend at the top") +
expressionCor(df = expr, legend_pos = "bottom", legend_title = "Legend at the bottom"))
expressionCor(df = expr, legend_size = c(5,50)) +
expressionCor(df = expr, legend_pos = "bottom", legend_size = c(5,50))
expressionCor(df = expr, legend_frame_width = 40)
expressionCor(df = expr, ticks = T)
expressionCor(df = expr, ticks = T, ticks_color = "black")
expressionCor(df = expr, ticks = F, ticks_color = "black")
